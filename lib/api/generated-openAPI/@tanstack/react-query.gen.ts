// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { deleteFile, generatePresignedUploadUrl, getApiMapsAutocomplete, getApiMapsPlaceDetails, getApiMapsPlaceTypes, getApiMapsSearchNearbyWithDetails, getApiMapsV2Autocomplete, getApiMapsV2PlaceDetails, getApiMapsV2PlaceTypes, getApiMapsV2SearchNearbyWithDetails, getApiPlaces, getApiPlacesById, getApiReviewsPlaceByPlaceId, getFileInfo, listFiles, type Options, patchApiPlacesByPlaceId, postApiAuthLogin, postApiAuthRegister, postApiPlacesImportFromMap, postApiReviews, uploadFile } from '../sdk.gen';
import type { DeleteFileData, DeleteFileError, DeleteFileResponse, GeneratePresignedUploadUrlData, GeneratePresignedUploadUrlError, GeneratePresignedUploadUrlResponse, GetApiMapsAutocompleteData, GetApiMapsAutocompleteError, GetApiMapsAutocompleteResponse, GetApiMapsPlaceDetailsData, GetApiMapsPlaceDetailsError, GetApiMapsPlaceDetailsResponse, GetApiMapsPlaceTypesData, GetApiMapsPlaceTypesResponse, GetApiMapsSearchNearbyWithDetailsData, GetApiMapsSearchNearbyWithDetailsError, GetApiMapsSearchNearbyWithDetailsResponse, GetApiMapsV2AutocompleteData, GetApiMapsV2AutocompleteError, GetApiMapsV2AutocompleteResponse, GetApiMapsV2PlaceDetailsData, GetApiMapsV2PlaceDetailsError, GetApiMapsV2PlaceDetailsResponse, GetApiMapsV2PlaceTypesData, GetApiMapsV2PlaceTypesResponse, GetApiMapsV2SearchNearbyWithDetailsData, GetApiMapsV2SearchNearbyWithDetailsError, GetApiMapsV2SearchNearbyWithDetailsResponse, GetApiPlacesByIdData, GetApiPlacesByIdError, GetApiPlacesByIdResponse, GetApiPlacesData, GetApiPlacesError, GetApiPlacesResponse, GetApiReviewsPlaceByPlaceIdData, GetApiReviewsPlaceByPlaceIdError, GetApiReviewsPlaceByPlaceIdResponse, GetFileInfoData, GetFileInfoError, GetFileInfoResponse, ListFilesData, ListFilesError, ListFilesResponse, PatchApiPlacesByPlaceIdData, PatchApiPlacesByPlaceIdError, PatchApiPlacesByPlaceIdResponse, PostApiAuthLoginData, PostApiAuthLoginError, PostApiAuthLoginResponse, PostApiAuthRegisterData, PostApiAuthRegisterError, PostApiAuthRegisterResponse, PostApiPlacesImportFromMapData, PostApiPlacesImportFromMapError, PostApiPlacesImportFromMapResponse, PostApiReviewsData, PostApiReviewsError, PostApiReviewsResponse, UploadFileData, UploadFileError, UploadFileResponse } from '../types.gen';

/**
 * Login
 *
 * Authenticate user and return JWT token
 */
export const postApiAuthLoginMutation = (options?: Partial<Options<PostApiAuthLoginData>>): UseMutationOptions<PostApiAuthLoginResponse, PostApiAuthLoginError, Options<PostApiAuthLoginData>> => {
    const mutationOptions: UseMutationOptions<PostApiAuthLoginResponse, PostApiAuthLoginError, Options<PostApiAuthLoginData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiAuthLogin({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Register
 *
 * Create new user account
 */
export const postApiAuthRegisterMutation = (options?: Partial<Options<PostApiAuthRegisterData>>): UseMutationOptions<PostApiAuthRegisterResponse, PostApiAuthRegisterError, Options<PostApiAuthRegisterData>> => {
    const mutationOptions: UseMutationOptions<PostApiAuthRegisterResponse, PostApiAuthRegisterError, Options<PostApiAuthRegisterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiAuthRegister({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getApiPlacesQueryKey = (options?: Options<GetApiPlacesData>) => createQueryKey("getApiPlaces", options);

/**
 * Get all places
 *
 * Get list of places with optional filters
 */
export const getApiPlacesOptions = (options?: Options<GetApiPlacesData>) => queryOptions<GetApiPlacesResponse, GetApiPlacesError, GetApiPlacesResponse, ReturnType<typeof getApiPlacesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getApiPlaces({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getApiPlacesQueryKey(options)
});

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getApiPlacesInfiniteQueryKey = (options?: Options<GetApiPlacesData>): QueryKey<Options<GetApiPlacesData>> => createQueryKey("getApiPlaces", options, true);

/**
 * Get all places
 *
 * Get list of places with optional filters
 */
export const getApiPlacesInfiniteOptions = (options?: Options<GetApiPlacesData>) => {
    return infiniteQueryOptions<GetApiPlacesResponse, GetApiPlacesError, InfiniteData<GetApiPlacesResponse>, QueryKey<Options<GetApiPlacesData>>, string | Pick<QueryKey<Options<GetApiPlacesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetApiPlacesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getApiPlaces({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiPlacesInfiniteQueryKey(options)
    });
};

export const getApiPlacesByIdQueryKey = (options: Options<GetApiPlacesByIdData>) => createQueryKey("getApiPlacesById", options);

/**
 * Get place by ID
 */
export const getApiPlacesByIdOptions = (options: Options<GetApiPlacesByIdData>) => queryOptions<GetApiPlacesByIdResponse, GetApiPlacesByIdError, GetApiPlacesByIdResponse, ReturnType<typeof getApiPlacesByIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getApiPlacesById({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getApiPlacesByIdQueryKey(options)
});

/**
 * Import place from Goong Maps
 *
 * Fetch place details from Goong Maps and save to database
 */
export const postApiPlacesImportFromMapMutation = (options?: Partial<Options<PostApiPlacesImportFromMapData>>): UseMutationOptions<PostApiPlacesImportFromMapResponse, PostApiPlacesImportFromMapError, Options<PostApiPlacesImportFromMapData>> => {
    const mutationOptions: UseMutationOptions<PostApiPlacesImportFromMapResponse, PostApiPlacesImportFromMapError, Options<PostApiPlacesImportFromMapData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiPlacesImportFromMap({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update place information
 *
 * Update additional information for a place (requires authentication)
 */
export const patchApiPlacesByPlaceIdMutation = (options?: Partial<Options<PatchApiPlacesByPlaceIdData>>): UseMutationOptions<PatchApiPlacesByPlaceIdResponse, PatchApiPlacesByPlaceIdError, Options<PatchApiPlacesByPlaceIdData>> => {
    const mutationOptions: UseMutationOptions<PatchApiPlacesByPlaceIdResponse, PatchApiPlacesByPlaceIdError, Options<PatchApiPlacesByPlaceIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchApiPlacesByPlaceId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiMapsPlaceTypesQueryKey = (options?: Options<GetApiMapsPlaceTypesData>) => createQueryKey("getApiMapsPlaceTypes", options);

/**
 * Get available place types
 *
 * List of place types (static list for OSM)
 */
export const getApiMapsPlaceTypesOptions = (options?: Options<GetApiMapsPlaceTypesData>) => queryOptions<GetApiMapsPlaceTypesResponse, DefaultError, GetApiMapsPlaceTypesResponse, ReturnType<typeof getApiMapsPlaceTypesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getApiMapsPlaceTypes({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getApiMapsPlaceTypesQueryKey(options)
});

export const getApiMapsAutocompleteQueryKey = (options: Options<GetApiMapsAutocompleteData>) => createQueryKey("getApiMapsAutocomplete", options);

/**
 * Autocomplete place search (OSM)
 */
export const getApiMapsAutocompleteOptions = (options: Options<GetApiMapsAutocompleteData>) => queryOptions<GetApiMapsAutocompleteResponse, GetApiMapsAutocompleteError, GetApiMapsAutocompleteResponse, ReturnType<typeof getApiMapsAutocompleteQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getApiMapsAutocomplete({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getApiMapsAutocompleteQueryKey(options)
});

export const getApiMapsPlaceDetailsQueryKey = (options: Options<GetApiMapsPlaceDetailsData>) => createQueryKey("getApiMapsPlaceDetails", options);

/**
 * Get place details (OSM)
 */
export const getApiMapsPlaceDetailsOptions = (options: Options<GetApiMapsPlaceDetailsData>) => queryOptions<GetApiMapsPlaceDetailsResponse, GetApiMapsPlaceDetailsError, GetApiMapsPlaceDetailsResponse, ReturnType<typeof getApiMapsPlaceDetailsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getApiMapsPlaceDetails({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getApiMapsPlaceDetailsQueryKey(options)
});

export const getApiMapsSearchNearbyWithDetailsQueryKey = (options: Options<GetApiMapsSearchNearbyWithDetailsData>) => createQueryKey("getApiMapsSearchNearbyWithDetails", options);

/**
 * Search nearby places (OSM)
 */
export const getApiMapsSearchNearbyWithDetailsOptions = (options: Options<GetApiMapsSearchNearbyWithDetailsData>) => queryOptions<GetApiMapsSearchNearbyWithDetailsResponse, GetApiMapsSearchNearbyWithDetailsError, GetApiMapsSearchNearbyWithDetailsResponse, ReturnType<typeof getApiMapsSearchNearbyWithDetailsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getApiMapsSearchNearbyWithDetails({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getApiMapsSearchNearbyWithDetailsQueryKey(options)
});

export const getApiMapsV2PlaceTypesQueryKey = (options?: Options<GetApiMapsV2PlaceTypesData>) => createQueryKey("getApiMapsV2PlaceTypes", options);

/**
 * Get available place types
 *
 * List of place types for Goong API
 */
export const getApiMapsV2PlaceTypesOptions = (options?: Options<GetApiMapsV2PlaceTypesData>) => queryOptions<GetApiMapsV2PlaceTypesResponse, DefaultError, GetApiMapsV2PlaceTypesResponse, ReturnType<typeof getApiMapsV2PlaceTypesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getApiMapsV2PlaceTypes({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getApiMapsV2PlaceTypesQueryKey(options)
});

export const getApiMapsV2AutocompleteQueryKey = (options: Options<GetApiMapsV2AutocompleteData>) => createQueryKey("getApiMapsV2Autocomplete", options);

/**
 * Autocomplete place search (Goong)
 *
 *
 * Places Search by keyword with autocomplete.
 *
 * **Session Token Usage:**
 * - Use UUID v4 to group multiple autocomplete requests in one search session
 * - Helps optimize billing (charges per session instead of per request)
 * - Enables better caching and analytics
 * - Example: a68dfa01-a5aa-47d1-aaa7-a3184896b283
 *
 * **Location Format:** latitude,longitude (e.g., "21.0285,105.8542")
 *
 */
export const getApiMapsV2AutocompleteOptions = (options: Options<GetApiMapsV2AutocompleteData>) => queryOptions<GetApiMapsV2AutocompleteResponse, GetApiMapsV2AutocompleteError, GetApiMapsV2AutocompleteResponse, ReturnType<typeof getApiMapsV2AutocompleteQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getApiMapsV2Autocomplete({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getApiMapsV2AutocompleteQueryKey(options)
});

export const getApiMapsV2PlaceDetailsQueryKey = (options: Options<GetApiMapsV2PlaceDetailsData>) => createQueryKey("getApiMapsV2PlaceDetails", options);

/**
 * Get place details (Goong)
 */
export const getApiMapsV2PlaceDetailsOptions = (options: Options<GetApiMapsV2PlaceDetailsData>) => queryOptions<GetApiMapsV2PlaceDetailsResponse, GetApiMapsV2PlaceDetailsError, GetApiMapsV2PlaceDetailsResponse, ReturnType<typeof getApiMapsV2PlaceDetailsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getApiMapsV2PlaceDetails({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getApiMapsV2PlaceDetailsQueryKey(options)
});

export const getApiMapsV2SearchNearbyWithDetailsQueryKey = (options: Options<GetApiMapsV2SearchNearbyWithDetailsData>) => createQueryKey("getApiMapsV2SearchNearbyWithDetails", options);

/**
 * Search nearby places (Goong)
 */
export const getApiMapsV2SearchNearbyWithDetailsOptions = (options: Options<GetApiMapsV2SearchNearbyWithDetailsData>) => queryOptions<GetApiMapsV2SearchNearbyWithDetailsResponse, GetApiMapsV2SearchNearbyWithDetailsError, GetApiMapsV2SearchNearbyWithDetailsResponse, ReturnType<typeof getApiMapsV2SearchNearbyWithDetailsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getApiMapsV2SearchNearbyWithDetails({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getApiMapsV2SearchNearbyWithDetailsQueryKey(options)
});

/**
 * Create a review
 *
 * Create a new review for a place
 */
export const postApiReviewsMutation = (options?: Partial<Options<PostApiReviewsData>>): UseMutationOptions<PostApiReviewsResponse, PostApiReviewsError, Options<PostApiReviewsData>> => {
    const mutationOptions: UseMutationOptions<PostApiReviewsResponse, PostApiReviewsError, Options<PostApiReviewsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiReviews({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiReviewsPlaceByPlaceIdQueryKey = (options: Options<GetApiReviewsPlaceByPlaceIdData>) => createQueryKey("getApiReviewsPlaceByPlaceId", options);

/**
 * Get place reviews
 *
 * Get all reviews for a specific place
 */
export const getApiReviewsPlaceByPlaceIdOptions = (options: Options<GetApiReviewsPlaceByPlaceIdData>) => queryOptions<GetApiReviewsPlaceByPlaceIdResponse, GetApiReviewsPlaceByPlaceIdError, GetApiReviewsPlaceByPlaceIdResponse, ReturnType<typeof getApiReviewsPlaceByPlaceIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getApiReviewsPlaceByPlaceId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getApiReviewsPlaceByPlaceIdQueryKey(options)
});

/**
 * Upload file to MinIO storage
 */
export const uploadFileMutation = (options?: Partial<Options<UploadFileData>>): UseMutationOptions<UploadFileResponse, UploadFileError, Options<UploadFileData>> => {
    const mutationOptions: UseMutationOptions<UploadFileResponse, UploadFileError, Options<UploadFileData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await uploadFile({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const generatePresignedUploadUrlQueryKey = (options: Options<GeneratePresignedUploadUrlData>) => createQueryKey("generatePresignedUploadUrl", options);

/**
 * Generate a presigned URL for uploading files
 */
export const generatePresignedUploadUrlOptions = (options: Options<GeneratePresignedUploadUrlData>) => queryOptions<GeneratePresignedUploadUrlResponse, GeneratePresignedUploadUrlError, GeneratePresignedUploadUrlResponse, ReturnType<typeof generatePresignedUploadUrlQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await generatePresignedUploadUrl({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: generatePresignedUploadUrlQueryKey(options)
});

export const getFileInfoQueryKey = (options: Options<GetFileInfoData>) => createQueryKey("getFileInfo", options);

/**
 * Get file information from MinIO
 */
export const getFileInfoOptions = (options: Options<GetFileInfoData>) => queryOptions<GetFileInfoResponse, GetFileInfoError, GetFileInfoResponse, ReturnType<typeof getFileInfoQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getFileInfo({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getFileInfoQueryKey(options)
});

/**
 * Delete file from MinIO storage
 */
export const deleteFileMutation = (options?: Partial<Options<DeleteFileData>>): UseMutationOptions<DeleteFileResponse, DeleteFileError, Options<DeleteFileData>> => {
    const mutationOptions: UseMutationOptions<DeleteFileResponse, DeleteFileError, Options<DeleteFileData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteFile({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listFilesQueryKey = (options?: Options<ListFilesData>) => createQueryKey("listFiles", options);

/**
 * List files in MinIO bucket
 */
export const listFilesOptions = (options?: Options<ListFilesData>) => queryOptions<ListFilesResponse, ListFilesError, ListFilesResponse, ReturnType<typeof listFilesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listFiles({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listFilesQueryKey(options)
});
